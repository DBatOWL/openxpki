import Component from '@glimmer/component';
import { action } from "@ember/object";
import { debug } from '@ember/debug';
import { guidFor } from '@ember/object/internals';

import uPlot from 'uplot';
import seriesBarsPlugin from './uplot/seriesbars-plugin';

//import 'uplot/dist/uPlot.min.css';
//import wheelZoom from './chart/plugin-wheelzoom.js'

/**
...

```html
<OxiBase::Chart .../>
```

@module oxi-base/chart
@param list { array } - List of hashes defining the options.
*/

export default class OxiChartComponent extends Component {
    guid;
    options;
    data;

    // x - timestamp
    // y - BTC price
    // y - RSI
    // y - RSI MA

    constructor() {
        super(...arguments);

        this.guid = guidFor(this);
        /*
         * Options
         */
        // Evaluate given options and set defaults
        const {
            width = 400,
            height = 200,
            title = "",
            cssClass = "",
            x_is_timestamp = true,
            y_axes = [ {} ], // default: one array item to make sure the loop below creates left Y-axis
            legend_label = (this.args.options.y_axes ? true : false),
            legend_value = false,
            legend_date_format = '{YYYY}-{MM}-{DD}, {HH}:{mm}:{ss}',
            type = 'line',
            bar_group_labels,
            bar_vertical = false,
        } = this.args.options ?? {};

        // assemble uPlot options
        let uplotOptions = {
            width,
            height,
            title,
            class: cssClass,
            legend: {
                show: legend_label,
                live: legend_value,
            },
            scales: {
                x: {
                    time: x_is_timestamp,
                },
                'auto': {
                    auto: true,
                },
                '%': {
                    auto: false,
                    range: (self) => [ 0, 100 ],
                },
            },
            series: [
                {}, // x values
            ],
            axes: [
                {
                    time: true,
                    values: this.axisTimestampConfig(),
                }, // x axis
            ],
        };

        /*
         * LINE chart
         */
        // set custom date format
        if (type == 'line' && x_is_timestamp) {
            // format strings: https://github.com/leeoniya/uPlot/blob/1.6.3/src/fmtDate.js#L74
            let dateFormatter = uPlot.fmtDate(legend_date_format);
            uplotOptions.series[0].value = (self, rawValue) => rawValue == null ? "-" : dateFormatter(new Date(rawValue * 1000));
        }

        /*
         * BAR chart
         */
        if (type == 'bar') {
            uPlot.assign(uplotOptions, {
                scales: {
                    x: {
                        time: false,
                        values: undefined,
                    },
                },
                plugins: [
                    seriesBarsPlugin({
                        labels: () => this.args.data.map(group => bar_group_labels ? bar_group_labels[group[0]] : group[0]), // group / time series
                        ori: bar_vertical ? 1 : 0,
                        dir: 1,
                    }),
                ],
            });
        }

        /*
         * Series
         */
        let autoScaleId = 0;
        for (const graph of y_axes) {
            const {
                label = '',
                color = 'rgba(0, 100, 200, 1)',
                fill,
                line_width = 1,
                scale = 'auto',
            } = graph;

            // Auto-generate scale if an array [min, max] was specified
            let _scale = scale;
            if (Array.isArray(scale)) {
                _scale = `_autogenerated_${++autoScaleId}`;
                uplotOptions.scales[_scale] = {
                    auto: false,
                    range: () => scale,
                };
            }

            let seriesOpts = {
                label,
                scale: _scale,
                fill: fill ?? this.reducedAlphaColor(color),
                width: line_width/window.devicePixelRatio,
                //value: (self, rawValue) => rawValue == null ? "-" : rawValue.toFixed(0),
            }
            if (type == 'line') {
                seriesOpts.stroke = color;
            }
            if (type == 'bar') {
                seriesOpts.fill = color;
            }
            uplotOptions.series.push(seriesOpts);

            // add up to 2 axis (left and right)
            if (uplotOptions.axes.length < 3) {
                let axis = {
                    scale: _scale,
                    space: Math.max((bar_vertical ? width : height) / 20, 15),
                    //labelSize: 150,
                    size: 60,
                    stroke: type == 'bar' ? 'black' : color,
                };
                // special treatment for percent
                if (_scale == '%') uPlot.assign(axis, {
                    values: (u, vals, space) => vals.map(v => `${v.toFixed(0)}%`),
                });
                // second axis
                if (uplotOptions.axes.length == 2) {
                    // skip if same scale as first axis
                    if (uplotOptions.axes[1].scale == _scale) continue;
                    // right hand side, no grid
                    uPlot.assign(axis, {
                        side: 1,
                        grid: { show: false },
                    })
                }
                uplotOptions.axes.push(axis);
            }
        }

        this.options = uplotOptions;

        /*
         * Convert data from
         * from [ [x1, price1, rsi1], [x2, price2, rsi2] ]
         *   to [ [x1, x2], [price1, price2], [rsi1, rsi2] ]
         */
        this.data = [];
        for (let i=0; i<this.args.data[0].length; i++) {
            this.data.push(this.args.data.map(row => +row[i]));
        }
    }

    @action
    plot(element) {
        new uPlot(this.options, this.data, (uplot, init) => {
            element.appendChild(uplot.root);
            init();
        })
    }

    reducedAlphaColor(cssColor) {
        const div = document.createElement('div');
        div.id = 'for-computed-style';

        div.style.color = cssColor;

        // appending the created element to the DOM
        document.querySelector('body').appendChild(div);

        const match = getComputedStyle(div).color.match(/^rgba?\s*\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d\.\d)\s*)?\)$/i);

        // removing element from the DOM
        document.querySelector('#for-computed-style').remove();

        if (match) {
            // match[0] is regex complete match (e.g. "rgb(0,0,0)"), not a regex capturing group
            let col = {
                r: match[1],
                g: match[2],
                b: match[3]
            };
            // if (match[4]) { // if alpha channel is present
            //     parsedColor.a = match[4];
            // }
            return `rgba(${col.r},${col.g},${col.b},0.1)`;
        } else {
            throw new Error(`Color ${cssColor} could not be parsed.`);
        }
    }

    // From https://github.com/leeoniya/uPlot/blob/1.6.3/src/opts.js#L65
    axisTimestampConfig() {
        const ms = 1e-3; // 1e-3 = set up for seconds, 1 = set up for milliseconds

        const NL = "\n";

        const yyyy    = "{YYYY}";
        const NLyyyy  = NL + yyyy;
        const md      = "{DD}.{MM}";
        const NLmd    = NL + md;
        const NLmdyy  = NL + "{DD}.{MM}.{YY}";

        const hmm     = "{H}:{mm}";
        const NLhmm = NL + hmm;
        const ss      = ":{ss}";

        const _ = null;

        const s  = ms * 1e3,
              m  = s  * 60,
              h  = m  * 60,
              d  = h  * 24,
              mo = d  * 30,
              y  = d  * 365;

        // [0]:   minimum num secs in the tick incr
        // [1]:   default tick format
        // [2-7]: rollover tick formats
        // [8]:   mode: 0: replace [1] -> [2-7], 1: concat [1] + [2-7]
        return [
        //   tick incr    default          year                    month   day                   hour    min       sec   mode
            [y,           yyyy,            _,                      _,      _,                    _,      _,        _,       1],
            [d * 28,      "{MMM}",         NLyyyy,                 _,      _,                    _,      _,        _,       1],
            [d,           md,              NLyyyy,                 _,      _,                    _,      _,        _,       1],
            [h,           "{H}",           NLmdyy,                 _,      NLmd,                 _,      _,        _,       1],
            [m,           hmm,             NLmdyy,                 _,      NLmd,                 _,      _,        _,       1],
            [s,           ss,              NLmdyy + " " + hmm,     _,      NLmd + " " + hmm,     _,      NLhmm,    _,       1],
            [ms,          ss + ".{fff}",   NLmdyy + " " + hmm,     _,      NLmd + " " + hmm,     _,      NLhmm,    _,       1],
        ];
    }
}
